<?php

/*
 * This file is part of sad_spirit/pg_gateway package
 *
 * (c) Alexey Borzov <avb@php.net>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

declare(strict_types=1);

namespace sad_spirit\pg_gateway;

use sad_spirit\pg_builder\SelectCommon;
use sad_spirit\pg_wrapper\ResultSet;

/**
 * Interface for table data gateways
 *
 * @psalm-type FragmentsInput = null|\Closure|Fragment|FragmentBuilder|iterable<Fragment|FragmentBuilder>
 */
interface TableGateway extends TableDefinition
{
    /**
     * Default alias for table accessed via TableGateway
     */
    public const ALIAS_SELF = 'self';
    /**
     * Default alias for a table being joined, used in join conditions
     */
    public const ALIAS_JOINED = 'joined';

    public const STATEMENT_COUNT  = 'count';
    public const STATEMENT_DELETE = 'delete';
    public const STATEMENT_INSERT = 'insert';
    public const STATEMENT_SELECT = 'select';
    public const STATEMENT_UPDATE = 'update';
    public const STATEMENT_UPSERT = 'upsert';

    /**
     * Generates a DELETE statement using given fragments and executes it with given parameters
     *
     * @param FragmentsInput $fragments
     * @param array<string, mixed> $parameters
     * @return ResultSet
     */
    public function delete($fragments = null, array $parameters = []): ResultSet;

    /**
     * Generates an INSERT statement for the given values using given fragments and executes it with given parameters
     *
     * @param array<string, mixed>|SelectCommon|SelectProxy $values This is either an array with table columns' values
     *                                                  or a SELECT statement that is used directly for the $values
     *                                                  property of Insert object being created
     *                                                  or a proxy for SELECT statement generated by another Gateway
     * @param FragmentsInput $fragments INSERT statements may have e.g. RETURNING and WITH clauses added via fragments
     * @param array<string, mixed> $parameters
     * @return ResultSet
     */
    public function insert($values, $fragments = null, array $parameters = []): ResultSet;

    /**
     * Returns an object that can execute SELECT / SELECT COUNT(*) queries using given fragments with given parameters
     *
     * @param FragmentsInput $fragments
     * @param array<string, mixed> $parameters
     * @return SelectProxy
     */
    public function select($fragments = null, array $parameters = []): SelectProxy;

    /**
     * Generates an UPDATE statement for the given columns using given fragments and executes it with given parameters
     *
     * @param array<string, mixed> $set New values for columns. The array may have instances of Expression or
     *                                  Nodes implementing ScalarExpression as values, those will be directly
     *                                  inserted into generated SQL
     * @param FragmentsInput $fragments
     * @param array<string, mixed> $parameters
     * @return ResultSet
     */
    public function update(array $set, $fragments = null, array $parameters = []): ResultSet;
}
